import os
import yaml
import pyperclip
import pyDeeEff


def ReadSettings(filename):
    default_settings = {
        'extensions': {'.bdf': '.emn', '.ldf': '.emp'},
        'include': ['U1'],
        'ifilter': ['none'],
        'exclude': ['none'],
        'exclude_bottom': True,
        'outline': ['0'],
        'thickness': 1.57,
        'offset_override': ['none'],
        'min_pth': 0.4,
        'refdes_suffix': '_',
        'sections': ['HEADER','BOARD_OUTLINE','PLACEMENT','DRILLED_HOLES','ELECTRICAL','MECHANICAL'],
    }
    try:
        with open('idf2tab.yaml', 'r') as f: 
            user_settings = yaml.safe_load(f)
    except:
        user_settings = {}  # blank one if file doesn't work
    for setting in default_settings:
        if setting not in user_settings:
            user_settings[setting] = default_settings[setting]  # set to default
            print('Adding ' + setting + ' = ' + str(default_settings[setting]))
    with open('log.yaml', 'w') as f:
        yaml.dump(user_settings, f)
    return user_settings
# End


def keep(s):
    r = False  # default to not kept
    if s in settings['include'] or s[0] in settings['ifilter'] or '*' in settings['ifilter']:
        r = True
    if s in settings['exclude']:
        r = False
    return r
# End


# this function is an example of how to replace allegro default height with something smaller
# it is currently not called by the script
def libfix(s):
    if line.endswith('40.00'):  # default height in Allegro
        if line.startswith('85OHM'):
            return line[:-5] + '2.0'
        elif line.startswith('80-OHM'):
            return line[:-5] + '2.1'
        elif line.startswith('FIDUCIAL'):
            return line[:-5] + '2.2'
        elif line.startswith('SENSE_PAD'):
            return line[:-5] + '2.3'
        elif line.startswith('KELVIN'):
            return line[:-5] + '2.4'
        elif line.startswith('SMD_40P'):
            return line[:-5] + '2.5'
        elif line.startswith('80OHMDDR'):
            return line[:-5] + '2.6'
        else:
            print(line)
    return line


# start of script
settings = ReadSettings('idf2tab.yaml')
allFiles = os.listdir('.')  # get list of files/folders in current folder
fileList = [x for x in allFiles if x[-4:] in settings['extensions'] and not x.startswith('idf2tab')]  # filter list based on extension, skip files generated by this script
log = '\n'.join(fileList) + '\n\n'  # string for storing log file, start with file list
units = 1.0  # gets auto-set to something else if file is in THOU
outtab = ''   # string for storing tab version, appended by every file rather than being reset each iteration
end_sections = pyDeeEff.GetEndSections(settings['sections'])  # names of end keywords based on list provided above
for f in fileList:
    outlist = []  # list for storing output file lines
    output = ''   # string for storing output file
    count = {}    # blank dictionary for counting tokens per line

    # input and output
    log = log + 'Reading ' + f + '\n'  # log the input filename
    with open(f, 'r') as infile:
        lines = infile.read().splitlines()  # read lines
    # standard version of outfile:
    # outfile = 'idf2tab (' + f[:-4] + ')' + extensions[f[-4:]]
    # FreeCAD version of outfile, ONLY works for one file pair at a time:
    outfile = 'idf2tab' + settings['extensions'][f[-4:]]

    # pass the list of lines, get offset XY, add to log
    xoffset, yoffset = pyDeeEff.GetOffset(lines)
    if len(settings['offset_override']) == 2:
        xoffset = settings['offset_override'][0]
        yoffset = settings['offset_override'][1]
    zoffset = 0.0  # probably won't get used
    log = log + '   Offsets: ' +  '%.2f' % xoffset + ', ' + '%.2f' % yoffset + '\n'

    keep_next_line = False
    for line in lines:
        # libfix is disabled
        # line = libfix(line)  # correct height errors in library file
        words = pyDeeEff.GetTokens(line)  # split into tokens, keeps quotes (but google strips them later)
        length = len(words)  # length of list of words
        if words[0][1:] in settings['sections']:  # check for first word (minus the '.') being a keyword
            section = words[0][1:]
        if section == 'HEADER' and len(words) == 2:  # this line contains the filename and units
            words[0] = outfile  # set project name to file name
            if words[1] == 'THOU':
                units = 25.4/1000
                words[1] = 'MM'
                log = log + '   Conversion factor: ' + str(units) + '\n'
        if section == 'HEADER' and len(words) == 5 and words[2].startswith('allegro'):  # brd or lib, middle word is system name
            words[2] = 'pyDeeEff'  # replace with script name
        if section == 'BOARD_OUTLINE':
            if len(words) == 1 and settings['thickness'] > 0.0 and not words[0].startswith('.'):
                words[0] = '%.2f' % settings['thickness']
            if len(words) == 4:
                # print(words)
                words[1] = pyDeeEff.OffsetAndConvert(words[1], xoffset, units)
                words[2] = pyDeeEff.OffsetAndConvert(words[2], yoffset, units)
                words[3] = pyDeeEff.RoundOffAngle(words[3])
                if words[0] in settings['outline'] or '*' in settings['outline']:
                    pass  # keep entry because it's in the list
                else:
                    words = ['line has been removed',]  # remove entry
        if section == 'DRILLED_HOLES':
            if len(words) == 7:  # defines a hole
                dia = float(words[0]) * units
                if dia < settings['min_pth']:
                    words = ['line has been removed',]  # empty list so it doesn't get added
                else:
                    words[0] = pyDeeEff.OffsetAndConvert(words[0], 0.0,     units)
                    words[1] = pyDeeEff.OffsetAndConvert(words[1], xoffset, units)
                    words[2] = pyDeeEff.OffsetAndConvert(words[2], yoffset, units)
        if section == 'PLACEMENT':
            if words[0][1:] in settings['sections'] or words[0][1:] in end_sections:  # keep the keywords
                pass
            elif keep_next_line:  # was set last loop
                keep_next_line = False  # unset for next loop
                words[0] = pyDeeEff.OffsetAndConvert(words[0], xoffset, units)
                words[1] = pyDeeEff.OffsetAndConvert(words[1], yoffset, units)
                words[2] = pyDeeEff.OffsetAndConvert(words[2], zoffset, units)
                if words[4] == 'BOTTOM' and settings['exclude_bottom']:
                    outlist.pop()  # remove last line from output list
                    words = ['line has been removed',]  # empty list so it doesn't get added
            elif len(words) == 3 and keep(words[2]):  # refdes is to be kept
                keep_next_line = True  # keep next line as well
                words[2] = words[2] + settings['refdes_suffix']  # add optional suffix
            else:
                words = ['line has been removed',]  # empty list so it doesn't get added
        try:
            count[length] = count[length] + 1  # add one to counter
        except:
            count[length] = 1  # start new counter
        if section == '' or words[0] == 'line has been removed':
            pass  # skip line, may use later
        else:
            outlist.append(words)  # add good lines to output list
        if words[0][1:] in end_sections:  # check for first word (minus the '.') being a keyword
            section = ''
    log = log + '   ' + str(count) + '\n'
    for words in outlist:
        output = output + ' '.join(words) + '\n'  # join with spaces
        outtab = outtab + '\t'.join(words) + '\n'  # join with tabs
    log = log + 'Writing ' + outfile + '\n\n'  # log the output filename with an extra CRLF
    with open(outfile, 'w') as outfile:
        outfile.write(output)

with open('idf2tab.log', 'w') as logfile:
    logfile.write(log)

pyperclip.copy(outtab)  # put all data on clipboard, includes every file

# EOF
